(function (global) {
  var babelHelpers = global.babelHelpers = {};

  babelHelpers.interopRequireDefault = function (obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  };

  babelHelpers.interopRequireWildcard = function (obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  };
})(typeof global === "undefined" ? self : global);(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

/**
 * MUI Angular main module
 * @module angular/main
 */

(function (win) {
  // return if library has been loaded already
  if (win._muiAngularLoaded) return;else win._muiAngularLoaded = true;

  win.angular.module('mui', [require('src/angular/appbar'), require('src/angular/button'), require('src/angular/caret'), require('src/angular/container'), require('src/angular/divider'), require('src/angular/dropdown'), require('src/angular/dropdown-item'), require('src/angular/panel'), require('src/angular/input'), require('src/angular/row'), require('src/angular/col'), require('src/angular/tabs'), require('src/angular/radio'), require('src/angular/checkbox'), require('src/angular/select'), require('src/angular/form')]);
})(window);

},{"src/angular/appbar":6,"src/angular/button":7,"src/angular/caret":8,"src/angular/checkbox":9,"src/angular/col":10,"src/angular/container":11,"src/angular/divider":12,"src/angular/dropdown":14,"src/angular/dropdown-item":13,"src/angular/form":15,"src/angular/input":16,"src/angular/panel":17,"src/angular/radio":18,"src/angular/row":19,"src/angular/select":20,"src/angular/tabs":21}],2:[function(require,module,exports){
"use strict";

/**
 * MUI config module
 * @module config
 */

/** Define module API */
module.exports = {
  /** Use debug mode */
  debug: true
};

},{}],3:[function(require,module,exports){
/**
 * MUI CSS/JS form helpers module
 * @module lib/forms.py
 */

'use strict';

var wrapperPadding = 15,
    // from CSS
inputHeight = 32,
    // from CSS
rowHeight = 42,
    // from CSS
menuPadding = 8; // from CSS


/**
 * Menu position/size/scroll helper
 * @returns {Object} Object with keys 'height', 'top', 'scrollTop'
 */
function getMenuPositionalCSSFn(wrapperEl, numRows, selectedRow) {
  var viewHeight = document.documentElement.clientHeight;

  // determine 'height'
  var h = numRows * rowHeight + 2 * menuPadding,
      height = Math.min(h, viewHeight);

  // determine 'top'
  var top, initTop, minTop, maxTop;

  initTop = menuPadding + rowHeight - (wrapperPadding + inputHeight);
  initTop -= selectedRow * rowHeight;

  minTop = -1 * wrapperEl.getBoundingClientRect().top;
  maxTop = viewHeight - height + minTop;

  top = Math.min(Math.max(initTop, minTop), maxTop);

  // determine 'scrollTop'
  var scrollTop = 0,
      scrollIdeal,
      scrollMax;

  if (h > viewHeight) {
    scrollIdeal = menuPadding + (selectedRow + 1) * rowHeight - (-1 * top + wrapperPadding + inputHeight);
    scrollMax = numRows * rowHeight + 2 * menuPadding - height;
    scrollTop = Math.min(scrollIdeal, scrollMax);
  }

  return {
    'height': height + 'px',
    'top': top + 'px',
    'scrollTop': scrollTop
  };
}

/** Define module API */
module.exports = {
  getMenuPositionalCSS: getMenuPositionalCSSFn
};

},{}],4:[function(require,module,exports){
/**
 * MUI CSS/JS jqLite module
 * @module lib/jqLite
 */

'use strict';

/**
 * Add a class to an element.
 * @param {Element} element - The DOM element.
 * @param {string} cssClasses - Space separated list of class names.
 */

function jqLiteAddClass(element, cssClasses) {
  if (!cssClasses || !element.setAttribute) return;

  var existingClasses = _getExistingClasses(element),
      splitClasses = cssClasses.split(' '),
      cssClass;

  for (var i = 0; i < splitClasses.length; i++) {
    cssClass = splitClasses[i].trim();
    if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
      existingClasses += cssClass + ' ';
    }
  }

  element.setAttribute('class', existingClasses.trim());
}

/**
 * Get or set CSS properties.
 * @param {Element} element - The DOM element.
 * @param {string} [name] - The property name.
 * @param {string} [value] - The property value.
 */
function jqLiteCss(element, name, value) {
  // Return full style object
  if (name === undefined) {
    return getComputedStyle(element);
  }

  var nameType = jqLiteType(name);

  // Set multiple values
  if (nameType === 'object') {
    for (var key in name) {
      element.style[_camelCase(key)] = name[key];
    }return;
  }

  // Set a single value
  if (nameType === 'string' && value !== undefined) {
    element.style[_camelCase(name)] = value;
  }

  var styleObj = getComputedStyle(element),
      isArray = jqLiteType(name) === 'array';

  // Read single value
  if (!isArray) return _getCurrCssProp(element, name, styleObj);

  // Read multiple values
  var outObj = {},
      key;

  for (var i = 0; i < name.length; i++) {
    key = name[i];
    outObj[key] = _getCurrCssProp(element, key, styleObj);
  }

  return outObj;
}

/**
 * Check if element has class.
 * @param {Element} element - The DOM element.
 * @param {string} cls - The class name string.
 */
function jqLiteHasClass(element, cls) {
  if (!cls || !element.getAttribute) return false;
  return _getExistingClasses(element).indexOf(' ' + cls + ' ') > -1;
}

/**
 * Return the type of a variable.
 * @param {} somevar - The JavaScript variable.
 */
function jqLiteType(somevar) {
  // handle undefined
  if (somevar === undefined) return 'undefined';

  // handle others (of type [object <Type>])
  var typeStr = Object.prototype.toString.call(somevar);
  if (typeStr.indexOf('[object ') === 0) {
    return typeStr.slice(8, -1).toLowerCase();
  } else {
    throw new Error("MUI: Could not understand type: " + typeStr);
  }
}

/**
 * Attach an event handler to a DOM element
 * @param {Element} element - The DOM element.
 * @param {string} events - Space separated event names.
 * @param {Function} callback - The callback function.
 * @param {Boolean} useCapture - Use capture flag.
 */
function jqLiteOn(element, events, callback, useCapture) {
  useCapture = useCapture === undefined ? false : useCapture;

  var cache = element._muiEventCache = element._muiEventCache || {};

  events.split(' ').map(function (event) {
    // add to DOM
    element.addEventListener(event, callback, useCapture);

    // add to cache
    cache[event] = cache[event] || [];
    cache[event].push([callback, useCapture]);
  });
}

/**
 * Remove an event handler from a DOM element
 * @param {Element} element - The DOM element.
 * @param {string} events - Space separated event names.
 * @param {Function} callback - The callback function.
 * @param {Boolean} useCapture - Use capture flag.
 */
function jqLiteOff(element, events, callback, useCapture) {
  useCapture = useCapture === undefined ? false : useCapture;

  // remove from cache
  var cache = element._muiEventCache = element._muiEventCache || {},
      argsList,
      args,
      i;

  events.split(' ').map(function (event) {
    argsList = cache[event] || [];

    i = argsList.length;
    while (i--) {
      args = argsList[i];

      // remove all events if callback is undefined
      if (callback === undefined || args[0] === callback && args[1] === useCapture) {

        // remove from cache
        argsList.splice(i, 1);

        // remove from DOM
        element.removeEventListener(event, args[0], args[1]);
      }
    }
  });
}

/**
 * Attach an event hander which will only execute once per element per event
 * @param {Element} element - The DOM element.
 * @param {string} events - Space separated event names.
 * @param {Function} callback - The callback function.
 * @param {Boolean} useCapture - Use capture flag.
 */
function jqLiteOne(element, events, callback, useCapture) {
  events.split(' ').map(function (event) {
    jqLiteOn(element, event, function onFn(ev) {
      // execute callback
      if (callback) callback.apply(this, arguments);

      // remove wrapper
      jqLiteOff(element, event, onFn, useCapture);
    }, useCapture);
  });
}

/**
 * Get or set horizontal scroll position
 * @param {Element} element - The DOM element
 * @param {number} [value] - The scroll position
 */
function jqLiteScrollLeft(element, value) {
  var win = window;

  // get
  if (value === undefined) {
    if (element === win) {
      var docEl = document.documentElement;
      return (win.pageXOffset || docEl.scrollLeft) - (docEl.clientLeft || 0);
    } else {
      return element.scrollLeft;
    }
  }

  // set
  if (element === win) win.scrollTo(value, jqLiteScrollTop(win));else element.scrollLeft = value;
}

/**
 * Get or set vertical scroll position
 * @param {Element} element - The DOM element
 * @param {number} value - The scroll position
 */
function jqLiteScrollTop(element, value) {
  var win = window;

  // get
  if (value === undefined) {
    if (element === win) {
      var docEl = document.documentElement;
      return (win.pageYOffset || docEl.scrollTop) - (docEl.clientTop || 0);
    } else {
      return element.scrollTop;
    }
  }

  // set
  if (element === win) win.scrollTo(jqLiteScrollLeft(win), value);else element.scrollTop = value;
}

/**
 * Return object representing top/left offset and element height/width.
 * @param {Element} element - The DOM element.
 */
function jqLiteOffset(element) {
  var win = window,
      rect = element.getBoundingClientRect(),
      scrollTop = jqLiteScrollTop(win),
      scrollLeft = jqLiteScrollLeft(win);

  return {
    top: rect.top + scrollTop,
    left: rect.left + scrollLeft,
    height: rect.height,
    width: rect.width
  };
}

/**
 * Attach a callback to the DOM ready event listener
 * @param {Function} fn - The callback function.
 */
function jqLiteReady(fn) {
  var done = false,
      top = true,
      doc = document,
      win = doc.defaultView,
      root = doc.documentElement,
      add = doc.addEventListener ? 'addEventListener' : 'attachEvent',
      rem = doc.addEventListener ? 'removeEventListener' : 'detachEvent',
      pre = doc.addEventListener ? '' : 'on';

  var init = function init(e) {
    if (e.type == 'readystatechange' && doc.readyState != 'complete') {
      return;
    }

    (e.type == 'load' ? win : doc)[rem](pre + e.type, init, false);
    if (!done && (done = true)) fn.call(win, e.type || e);
  };

  var poll = function poll() {
    try {
      root.doScroll('left');
    } catch (e) {
      setTimeout(poll, 50);return;
    }
    init('poll');
  };

  if (doc.readyState == 'complete') {
    fn.call(win, 'lazy');
  } else {
    if (doc.createEventObject && root.doScroll) {
      try {
        top = !win.frameElement;
      } catch (e) {}
      if (top) poll();
    }
    doc[add](pre + 'DOMContentLoaded', init, false);
    doc[add](pre + 'readystatechange', init, false);
    win[add](pre + 'load', init, false);
  }
}

/**
 * Remove classes from a DOM element
 * @param {Element} element - The DOM element.
 * @param {string} cssClasses - Space separated list of class names.
 */
function jqLiteRemoveClass(element, cssClasses) {
  if (!cssClasses || !element.setAttribute) return;

  var existingClasses = _getExistingClasses(element),
      splitClasses = cssClasses.split(' '),
      cssClass;

  for (var i = 0; i < splitClasses.length; i++) {
    cssClass = splitClasses[i].trim();
    while (existingClasses.indexOf(' ' + cssClass + ' ') >= 0) {
      existingClasses = existingClasses.replace(' ' + cssClass + ' ', ' ');
    }
  }

  element.setAttribute('class', existingClasses.trim());
}

// ------------------------------
// Utilities
// ------------------------------
var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g,
    MOZ_HACK_REGEXP = /^moz([A-Z])/,
    ESCAPE_REGEXP = /([.*+?^=!:${}()|\[\]\/\\])/g;

function _getExistingClasses(element) {
  var classes = (element.getAttribute('class') || '').replace(/[\n\t]/g, '');
  return ' ' + classes + ' ';
}

function _camelCase(name) {
  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
    return offset ? letter.toUpperCase() : letter;
  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
}

function _escapeRegExp(string) {
  return string.replace(ESCAPE_REGEXP, "\\$1");
}

function _getCurrCssProp(elem, name, computed) {
  var ret;

  // try computed style
  ret = computed.getPropertyValue(name);

  // try style attribute (if element is not attached to document)
  if (ret === '' && !elem.ownerDocument) ret = elem.style[_camelCase(name)];

  return ret;
}

/**
 * Module API
 */
module.exports = {
  /** Add classes */
  addClass: jqLiteAddClass,

  /** Get or set CSS properties */
  css: jqLiteCss,

  /** Check for class */
  hasClass: jqLiteHasClass,

  /** Remove event handlers */
  off: jqLiteOff,

  /** Return offset values */
  offset: jqLiteOffset,

  /** Add event handlers */
  on: jqLiteOn,

  /** Add an execute-once event handler */
  one: jqLiteOne,

  /** DOM ready event handler */
  ready: jqLiteReady,

  /** Remove classes */
  removeClass: jqLiteRemoveClass,

  /** Check JavaScript variable instance type */
  type: jqLiteType,

  /** Get or set horizontal scroll position */
  scrollLeft: jqLiteScrollLeft,

  /** Get or set vertical scroll position */
  scrollTop: jqLiteScrollTop
};

},{}],5:[function(require,module,exports){
/**
 * MUI CSS/JS utilities module
 * @module lib/util
 */

'use strict';

var config = require('../config'),
    jqLite = require('./jqLite'),
    scrollLock = 0,
    scrollLockCls = 'mui-scroll-lock',
    scrollStyleEl,
    scrollEventHandler,
    _supportsPointerEvents;

scrollEventHandler = function scrollEventHandler(ev) {
  // stop propagation on window scroll events
  if (!ev.target.tagName) ev.stopImmediatePropagation();
};

/**
 * Logging function
 */
function logFn() {
  var win = window;

  if (config.debug && typeof win.console !== "undefined") {
    try {
      win.console.log.apply(win.console, arguments);
    } catch (a) {
      var e = Array.prototype.slice.call(arguments);
      win.console.log(e.join("\n"));
    }
  }
}

/**
 * Load CSS text in new stylesheet
 * @param {string} cssText - The css text.
 */
function loadStyleFn(cssText) {
  var doc = document,
      head;

  // copied from jQuery 
  head = doc.head || doc.getElementsByTagName('head')[0] || doc.documentElement;

  var e = doc.createElement('style');
  e.type = 'text/css';

  if (e.styleSheet) e.styleSheet.cssText = cssText;else e.appendChild(doc.createTextNode(cssText));

  // add to document
  head.insertBefore(e, head.firstChild);

  return e;
}

/**
 * Raise an error
 * @param {string} msg - The error message.
 */
function raiseErrorFn(msg, useConsole) {
  if (useConsole) {
    if (typeof console !== 'undefined') console.error('MUI Warning: ' + msg);
  } else {
    throw new Error('MUI: ' + msg);
  }
}

/**
 * Convert Classname object, with class as key and true/false as value, to an
 * class string.
 * @param  {Object} classes The classes
 * @return {String}         class string
 */
function classNamesFn(classes) {
  var cs = '';
  for (var i in classes) {
    cs += classes[i] ? i + ' ' : '';
  }
  return cs.trim();
}

/**
 * Check if client supports pointer events.
 */
function supportsPointerEventsFn() {
  // check cache
  if (_supportsPointerEvents !== undefined) return _supportsPointerEvents;

  var element = document.createElement('x');
  element.style.cssText = 'pointer-events:auto';
  _supportsPointerEvents = element.style.pointerEvents === 'auto';
  return _supportsPointerEvents;
}

/**
 * Create callback closure.
 * @param {Object} instance - The object instance.
 * @param {String} funcName - The name of the callback function.
 */
function callbackFn(instance, funcName) {
  return function () {
    instance[funcName].apply(instance, arguments);
  };
}

/**
 * Dispatch event.
 * @param {Element} element - The DOM element.
 * @param {String} eventType - The event type.
 * @param {Boolean} bubbles=true - If true, event bubbles.
 * @param {Boolean} cancelable=true = If true, event is cancelable
 * @param {Object} [data] - Data to add to event object
 */
function dispatchEventFn(element, eventType, bubbles, cancelable, data) {
  var ev = document.createEvent('HTMLEvents'),
      bubbles = bubbles !== undefined ? bubbles : true,
      cancelable = cancelable !== undefined ? cancelable : true,
      k;

  ev.initEvent(eventType, bubbles, cancelable);

  // add data to event object
  if (data) for (k in data) {
    ev[k] = data[k];
  } // dispatch
  if (element) element.dispatchEvent(ev);

  return ev;
}

/**
 * Turn on window scroll lock.
 */
function enableScrollLockFn() {
  // increment counter
  scrollLock += 1;

  // add lock
  if (scrollLock === 1) {
    var htmlEl = document.documentElement,
        top = jqLite.scrollTop(window),
        left = jqLite.scrollLeft(window),
        cssProps,
        cssStr;

    // define scroll lock class dynamically
    cssProps = ['position:fixed', 'top:' + -top + 'px', 'right:0', 'bottom:0', 'left:' + -left + 'px'];

    // scrollbar-y
    if (htmlEl.scrollHeight > htmlEl.clientHeight) {
      cssProps.push('overflow-y:scroll');
    }

    // scrollbar-x
    if (htmlEl.scrollWidth > htmlEl.clientWidth) {
      cssProps.push('overflow-x:scroll');
    }

    // define css class dynamically
    cssStr = '.' + scrollLockCls + '{';
    cssStr += cssProps.join(' !important;') + ' !important;}';
    scrollStyleEl = loadStyleFn(cssStr);

    // cancel 'scroll' event listener callbacks
    jqLite.on(window, 'scroll', scrollEventHandler, true);

    // add scroll lock
    jqLite.addClass(htmlEl, scrollLockCls);
  }
}

/**
 * Turn off window scroll lock.
 * @param {Boolean} resetPos - Reset scroll position to original value.
 */
function disableScrollLockFn(resetPos) {
  // ignore
  if (scrollLock === 0) return;

  // decrement counter
  scrollLock -= 1;

  // remove lock 
  if (scrollLock === 0) {
    var htmlEl = document.documentElement,
        top = parseInt(jqLite.css(htmlEl, 'top')),
        left = parseInt(jqLite.css(htmlEl, 'left'));

    // remove scroll lock and delete style element
    jqLite.removeClass(htmlEl, scrollLockCls);
    scrollStyleEl.parentNode.removeChild(scrollStyleEl);

    // restore scroll position
    window.scrollTo(-left, -top);

    // restore scroll event listeners
    jqLite.off(window, 'scroll', scrollEventHandler, true);
  }
}

/**
 * requestAnimationFrame polyfilled
 * @param {Function} callback - The callback function
 */
function requestAnimationFrameFn(callback) {
  var fn = window.requestAnimationFrame;
  if (fn) fn(callback);else setTimeout(callback, 0);
}

/**
 * Define the module API
 */
module.exports = {
  /** Create callback closures */
  callback: callbackFn,

  /** Classnames object to string */
  classNames: classNamesFn,

  /** Disable scroll lock */
  disableScrollLock: disableScrollLockFn,

  /** Dispatch event */
  dispatchEvent: dispatchEventFn,

  /** Enable scroll lock */
  enableScrollLock: enableScrollLockFn,

  /** Log messages to the console when debug is turned on */
  log: logFn,

  /** Load CSS text as new stylesheet */
  loadStyle: loadStyleFn,

  /** Raise MUI error */
  raiseError: raiseErrorFn,

  /** Request animation frame */
  requestAnimationFrame: requestAnimationFrameFn,

  /** Support Pointer Events check */
  supportsPointerEvents: supportsPointerEventsFn
};

},{"../config":2,"./jqLite":4}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.appbar'; /**
                                * MUI Angular Appbar Component
                                * @module angular/appbar
                                */

_angular2.default.module(moduleName, []).directive('muiAppbar', function () {
  return {
    restrict: 'AE',
    transclude: true,
    replace: true,
    template: '<div class="mui-appbar"></div>',
    link: function link(scope, element, attrs, controller, transcludeFn) {
      // use transcludeFn to pass ng-controller on parent element
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var _jqLite = require('../js/lib/jqLite');

var jqLite = babelHelpers.interopRequireWildcard(_jqLite);

var _util = require('../js/lib/util');

var util = babelHelpers.interopRequireWildcard(_util);


var moduleName = 'mui.button',
    rippleClass = 'mui-ripple-effect',
    supportsTouch = 'ontouchstart' in document.documentElement,
    mouseDownEvents = supportsTouch ? 'touchstart' : 'mousedown',
    mouseUpEvents = supportsTouch ? 'touchend' : 'mouseup mouseleave',
    animationDuration = 600; /**
                              * MUI Angular Button Component
                              * @module angular/button
                              */

_angular2.default.module(moduleName, []).directive('muiButton', function () {
  return {
    restrict: 'AE',
    replace: true,
    template: '<button class="mui-btn" mui-ripple ng-transclude></button>',
    transclude: true,
    link: function link(scope, element, attrs) {
      var isUndef = _angular2.default.isUndefined,
          el = element[0];

      // disable MUI js
      el._muiDropdown = true;
      el._muiRipple = true;

      // handle disabled attribute
      if (!isUndef(attrs.disabled) && isUndef(attrs.ngDisabled)) {
        element.prop('disabled', true);
      }

      // set button styles        
      _angular2.default.forEach(['variant', 'color', 'size'], function (attrName) {
        var attrVal = attrs[attrName];
        if (attrVal) element.addClass('mui-btn--' + attrVal);
      });
    }
  };
}).directive('muiRipple', ['$timeout', function ($timeout) {
  return {
    restrict: 'A',
    link: function link(scope, element, attrs) {
      // add mousedown event handler
      element.on(mouseDownEvents, mouseDownHandler);
    }
  };
}]);

/**
 * MouseDown event handler.
 * @param {Event} ev - The DOM event
 */
function mouseDownHandler(ev) {
  var element = _angular2.default.element(this);

  // exit if disabled
  if (element.prop('disabled')) return;

  // add mouseup event handler once
  if (!this.muiMouseUp) {
    element.on(mouseUpEvents, mouseUpHandler);
    this.muiMouseUp = true;
  }

  // get (x, y) position of click
  var offset = jqLite.offset(this),
      clickEv = ev.type === 'touchstart' ? ev.touches[0] : ev,
      xPos = clickEv.pageX - offset.left,
      yPos = clickEv.pageY - offset.top,
      diameter,
      radius,
      rippleEl;

  // calculate diameter
  diameter = Math.sqrt(offset.width * offset.width + offset.height * offset.height) * 2;

  // create ripple element
  rippleEl = _angular2.default.element('<div class="' + rippleClass + '"></div>');

  radius = diameter / 2;

  rippleEl.css({
    height: diameter + 'px',
    width: diameter + 'px',
    top: yPos - radius + 'px',
    left: xPos - radius + 'px'
  });

  // add to DOM
  element.append(rippleEl);

  // start animation
  util.requestAnimationFrame(function () {
    rippleEl.addClass('mui--animate-in mui--active');
  });
}

/**
 * MouseUp event handler.
 * @param {Event} ev - The DOM event
 */
function mouseUpHandler(ev) {
  var children = this.children,
      i = children.length,
      rippleEls = [],
      el;

  // animate out ripples
  while (i--) {
    el = children[i];
    if (jqLite.hasClass(el, rippleClass)) {
      jqLite.addClass(el, 'mui--animate-out');
      rippleEls.push(el);
    }
  }

  // remove ripples after animation
  if (rippleEls.length) {
    setTimeout(function () {
      var i = rippleEls.length,
          el,
          parentNode;

      // remove elements
      while (i--) {
        el = rippleEls[i];
        parentNode = el.parentNode;
        if (parentNode) parentNode.removeChild(el);
      }
    }, animationDuration);
  }
}

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"../js/lib/jqLite":4,"../js/lib/util":5,"angular":"aeQg5j"}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.caret'; /**
                               * MUI Angular Caret Component
                               * @module angular/caret
                               */

_angular2.default.module(moduleName, []).directive('muiCaret', function () {
  return {
    restrict: 'AE',
    replace: true,
    template: '<span class="mui-caret"></span>'
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.checkbox'; /**
                                  * MUI Angular Checkbox Component
                                  * @module angular/checkox
                                  */

_angular2.default.module(moduleName, []).directive('muiCheckbox', function () {
  return {
    restrict: 'AE',
    replace: true,
    require: ['?ngModel'],
    scope: {
      label: '@',
      name: '@',
      value: '@',
      ngModel: '=',
      ngDisabled: '='
    },
    template: '<div class="mui-checkbox">' + '<label>' + '<input type="checkbox" ' + 'name={{name}} ' + 'value={{value}} ' + 'ng-model="ngModel" ' + 'ng-disabled="ngDisabled" ' + '>{{label}}</label> ' + '</div>'
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.col'; /**
                             * MUI Angular Col (Grid) Component
                             * @module angular/col
                             */

_angular2.default.module(moduleName, []).directive('muiCol', function () {
  return {
    restrict: 'AE',
    scope: true,
    replace: true,
    template: '<div></div>',
    transclude: true,
    link: function link(scope, element, attrs, controller, transcludeFn) {
      // use transcludeFn to pass ng-controller on parent element
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });

      // iterate through breakpoints
      var breakpoints = {
        'xs': 'mui-col-xs-',
        'sm': 'mui-col-sm-',
        'md': 'mui-col-md-',
        'lg': 'mui-col-lg-',
        'xs-offset': 'mui-col-xs-offset-',
        'sm-offset': 'mui-col-sm-offset-',
        'md-offset': 'mui-col-md-offset-',
        'lg-offset': 'mui-col-lg-offset-'
      };

      _angular2.default.forEach(breakpoints, function (value, key) {
        var attrVal = attrs[attrs.$normalize(key)];
        if (attrVal) element.addClass(value + attrVal);
      });
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.container'; /**
                                   * MUI Angular Container Component
                                   * @module angular/container
                                   */

_angular2.default.module(moduleName, []).directive('muiContainer', function () {
  return {
    restrict: 'AE',
    template: '<div class="mui-container"></div>',
    transclude: true,
    scope: true,
    replace: true,
    link: function link(scope, element, attrs, controller, transcludeFn) {
      // use transcludeFn to pass ng-controller on parent element
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });

      // handle fluid containers
      if (!_angular2.default.isUndefined(attrs.fluid)) {
        element.removeClass('mui-container').addClass('mui-container-fluid');
      }
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.divider'; /**
                                 * MUI Angular Divider Component
                                 * @module angular/divider
                                 */

_angular2.default.module(moduleName, []).directive('muiDivider', function () {
  return {
    restrict: 'AE',
    replace: true,
    compile: function compile(tElement, tAttrs) {
      tElement.addClass('mui-divider');
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.dropdown-item'; /**
                                       * MUI Angular DropdownItem Component
                                       * @module angular/dropdown-item
                                       */

_angular2.default.module(moduleName, []).directive('muiDropdownItem', function () {
  return {
    restrict: 'AE',
    replace: true,
    scope: {
      link: '@'
    },
    transclude: true,
    template: '<li><a href="{{link}}" ng-transclude></a></li>'
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.dropdown'; /**
                                  * MUI Angular Dropdown Component
                                  * @module angular/dropdown
                                  */

_angular2.default.module(moduleName, []).directive('muiDropdown', ['$timeout', '$compile', function ($timeout, $compile) {
  return {
    restrict: 'AE',
    transclude: true,
    replace: true,
    scope: {
      variant: '@',
      color: '@',
      size: '@',
      open: '=?',
      ngDisabled: '='
    },
    template: '<div class="mui-dropdown">' + '<mui-button ' + 'variant="{{variant}}" ' + 'color="{{color}}" ' + 'size="{{size}}" ' + 'ng-click="onClick($event);" ' + '></mui-button>' + '<ul class="mui-dropdown__menu" ng-transclude></ul>' + '</div>',
    link: function link(scope, element, attrs) {
      var dropdownClass = 'mui-dropdown',
          menuClass = 'mui-dropdown__menu',
          openClass = 'mui--is-open',
          rightClass = 'mui-dropdown__menu--right',
          isUndef = _angular2.default.isUndefined,
          menuEl,
          buttonEl;

      // save references
      menuEl = _angular2.default.element(element[0].querySelector('.' + menuClass));
      buttonEl = _angular2.default.element(element[0].querySelector('.mui-btn'));

      menuEl.css('margin-top', '-3px');

      // handle is-open
      if (!isUndef(attrs.open)) scope.open = true;

      // handle disabled
      if (!isUndef(attrs.disabled)) {
        buttonEl.attr('disabled', true);
      }

      // handle right-align
      if (!isUndef(attrs.rightAlign)) menuEl.addClass(rightClass);

      // handle no-caret
      if (!isUndef(attrs.noCaret)) buttonEl.html(attrs.label);else buttonEl.html(attrs.label + ' <mui-caret></mui-caret>');

      function closeDropdownFn() {
        scope.open = false;
        scope.$apply();
      }

      // handle menu open
      scope.$watch('open', function (newValue) {
        if (newValue === true) {
          menuEl.addClass(openClass);
          document.addEventListener('click', closeDropdownFn);
        } else if (newValue === false) {
          menuEl.removeClass(openClass);
          document.removeEventListener('click', closeDropdownFn);
        }
      });

      // click handler
      scope.onClick = function ($event) {
        // exit if disabled
        if (scope.disabled) return;

        // prevent form submission
        $event.preventDefault();
        $event.stopPropagation();

        // toggle open 
        if (scope.open) scope.open = false;else scope.open = true;
      };
    }
  };
}]);

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.form'; /**
                              * MUI Angular Form Directive
                              * @module angular/form
                              */

_angular2.default.module(moduleName, []).directive('muiFormInline', function () {
  return {
    restrict: 'A',
    link: function link(scope, element, attrs) {
      element.addClass('mui-form--inline');
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.input',
    emptyClass = 'mui--is-empty',
    notEmptyClass = 'mui--is-not-empty',
    dirtyClass = 'mui--is-dirty';

/**
 * Handle empty/not-empty/dirty classes.
 * @param {Element} elem - The angular-wrapped DOM element.
 */
/**
 * MUI Angular Input and Textarea Components
 * @module angular/input
 */

function handleEmptyClasses(inputEl, value) {
  if (value) inputEl.removeClass(emptyClass).addClass(notEmptyClass);else inputEl.removeClass(notEmptyClass).addClass(emptyClass);
}

/**
 * Build directive function.
 * @param {Boolean} isTextArea
 */
function inputFactory(isTextArea) {
  var emptyClass = 'mui--is-empty',
      notEmptyClass = 'mui--is-not-empty',
      dirtyClass = 'mui--is-dirty',
      scopeArgs,
      template;

  // defaults
  scopeArgs = {
    floatLabel: '@',
    hint: '@',
    label: '@',
    ngDisabled: '=',
    ngModel: '='
  };

  template = '<div class="mui-textfield">';

  // element-specific
  if (!isTextArea) {
    scopeArgs.type = '@';

    template += '<input ' + 'placeholder={{hint}} ' + 'type={{type}} ' + 'ng-change="onChange()" ' + 'ng-disabled="ngDisabled" ' + 'ng-focus="onFocus()" ' + 'ng-model="ngModel" ' + '>';
  } else {
    scopeArgs.rows = '@';

    template += '<textarea ' + 'placeholder={{hint}} ' + 'rows={{rows}} ' + 'ng-change="onChange()" ' + 'ng-disabled="ngDisabled" ' + 'ng-focus="onFocus()" ' + 'ng-model="ngModel" ' + '></textarea>';
  }

  // update template
  template += '<label>{{label}}</label></div>';

  // directive function
  return ['$timeout', function ($timeout) {
    return {
      restrict: 'AE',
      require: ['ngModel'],
      scope: scopeArgs,
      replace: true,
      template: template,
      link: function link(scope, element, attrs, controllers) {
        var inputEl = element.find('input') || element.find('textarea'),
            labelEl = element.find('label'),
            ngModelCtrl = controllers[0],
            formCtrl = controllers[1],
            isUndef = _angular2.default.isUndefined,
            el = inputEl[0];

        // disable MUI js
        if (el) el._muiTextfield = true;

        // remove attributes from wrapper
        element.removeAttr('ng-change');
        element.removeAttr('ng-model');

        // scope defaults
        if (!isTextArea) scope.type = scope.type || 'text';else scope.rows = scope.rows || 2;

        // autofocus
        if (!isUndef(attrs.autofocus)) inputEl[0].focus();

        // required
        if (!isUndef(attrs.required)) inputEl.prop('required', true);

        // invalid
        if (!isUndef(attrs.invalid)) inputEl.addClass('mui--is-invalid');

        // set is-empty|is-no-empty
        handleEmptyClasses(inputEl, scope.ngModel);

        // float-label
        if (!isUndef(scope.floatLabel)) {
          element.addClass('mui-textfield--float-label');

          $timeout(function () {
            labelEl.css({
              'transition': '.15s ease-out',
              '-webkit-transition': '.15s ease-out',
              '-moz-transition': '.15s ease-out',
              '-o-transition': '.15s ease-out',
              '-ms-transition': '.15s ease-out'
            });
          }, 150);
        }

        // handle changes
        scope.onChange = function () {
          var val = scope.ngModel;

          // trigger ng-change
          if (ngModelCtrl) ngModelCtrl.$setViewValue(val);

          // set is-empty|is-no-empty
          handleEmptyClasses(inputEl, val);

          // add is-dirty
          inputEl.addClass(dirtyClass);
        };

        // handle focus event
        scope.onFocus = function () {
          inputEl.addClass(dirtyClass);
        };
      }
    };
  }];
}

_angular2.default.module(moduleName, []).directive('muiInput', inputFactory(false)).directive('muiTextarea', inputFactory(true));

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.panel'; /**
                               * MUI Angular Panel Component
                               * @module angular/panel
                               */

_angular2.default.module(moduleName, []).directive('muiPanel', function () {
  return {
    restrict: 'AE',
    replace: true,
    scope: true,
    template: '<div class="mui-panel"></div>',
    transclude: true,
    link: function link(scope, element, attr, controller, transcludeFn) {
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.radio'; /**
                               * MUI Angular Radio Component
                               * @module angular/radio
                               */

_angular2.default.module(moduleName, []).directive('muiRadio', function () {
  return {
    restrict: 'AE',
    replace: true,
    require: ['?ngModel'],
    scope: {
      label: '@',
      name: '@',
      value: '@',
      ngModel: '=',
      ngDisabled: '='
    },
    template: '<div class="mui-radio">' + '<label>' + '<input type="radio" ' + 'name={{name}} ' + 'value={{value}} ' + 'ng-model="ngModel" ' + 'ng-disabled="ngDisabled" ' + '>{{label}}</label> ' + '</div>'
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var moduleName = 'mui.row'; /**
                             * MUI Angular Grid/Row Module
                             * @module angular/row.js
                             */

_angular2.default.module('mui.row', []).directive('muiRow', function () {
  return {
    restrict: 'AE',
    scope: true,
    replace: true,
    template: '<div class="mui-row"></div>',
    transclude: true,
    link: function link(scope, element, attr, controller, transcludeFn) {
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });
    }
  };
});

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"angular":"aeQg5j"}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var _forms = require('../js/lib/forms');

var formlib = babelHelpers.interopRequireWildcard(_forms);

var _util = require('../js/lib/util');

var util = babelHelpers.interopRequireWildcard(_util);

var _jqLite = require('../js/lib/jqLite');

var jqLite = babelHelpers.interopRequireWildcard(_jqLite);
/**
 * MUI Angular Select Component
 * @module angular/select
 */

var moduleName = 'mui.select';

_angular2.default.module(moduleName, []).directive('muiSelect', ['$timeout', function ($timeout) {
  return {
    restrict: 'AE',
    require: ['ngModel'],
    scope: {
      label: '@',
      name: '@',
      ngDisabled: '=',
      ngModel: '='
    },
    replace: true,
    transclude: true,
    template: '<div class="mui-select" ' + 'ng-blur="onWrapperBlurOrFocus($event)" ' + 'ng-click="onWrapperClick($event)" ' + 'ng-focus="onWrapperBlurOrFocus($event)" ' + 'ng-keydown="onWrapperKeydown($event)">' + '<select ' + 'name="{{name}}" ' + 'ng-disabled="ngDisabled" ' + 'ng-model="ngModel" ' + 'ng-mousedown="onInnerMousedown($event)" ' + '>' + '<option ng-repeat="option in options" value="{{option.value}}">{{option.label}}</option>' + '</select>' + '<label>{{label}}</label>' + '<div ' + 'class="mui-select__menu"' + 'ng-show="!useDefault && isOpen"> ' + '<div ' + 'ng-click="chooseOption($event, option)" ' + 'ng-repeat="option in options track by $index" ' + 'ng-class=\'{"mui--is-selected": $index === menuIndex}\'>{{option.label}}</div>' + '</div>' + '</div>',
    link: function link(scope, element, attrs, controller, transcludeFn) {
      var wrapperEl = element,
          menuEl = element.find('div'),
          selectEl = element.find('select'),
          isUndef = _angular2.default.isUndefined,
          cacheIndex;

      // disable MUI js
      selectEl[0]._muiSelect = true;

      // init scope
      scope.options = [];
      scope.isOpen = false;
      scope.useDefault = 'ontouchstart' in document.documentElement ? true : false;
      scope.origTabIndex = selectEl[0].tabIndex;
      scope.menuIndex = 0;

      // handle `use-default` attribute
      if (!isUndef(attrs.useDefault)) scope.useDefault = true;

      // use tabIndex to make wrapper or inner focusable
      if (scope.useDefault === false) {
        wrapperEl.prop('tabIndex', '0');
        selectEl.prop('tabIndex', '-1');
      } else {
        wrapperEl.prop('tabIndex', '-1');
        selectEl.prop('tabIndex', '0');
      }

      // extract <option> elements from children
      transcludeFn(function (clone) {
        var el, k;

        // iterate through children
        for (k in clone) {
          el = clone[k];

          // add option to scope
          if (el.tagName === 'MUI-OPTION') {
            scope.options.push({
              value: el.getAttribute('value'),
              label: el.getAttribute('label')
            });
          }
        }
      });

      /**
       * Handle blur and focus events on wrapper <div> element.
       * @param {Event} $event - Angular event instance
       */
      scope.onWrapperBlurOrFocus = function ($event) {
        // ignore events that bubbled up
        if (document.activeElement !== wrapperEl[0]) return;

        util.dispatchEvent(selectEl[0], $event.type, false, false);
      };

      /**
       * Handle click event on wrapper <div> element.
       * @param {Event} $event - Angular event instance
       */
      scope.onWrapperClick = function ($event) {
        // only left click, check default prevented and useDefault
        if ($event.button !== 0 || $event.defaultPrevented || scope.useDefault || selectEl[0].disabled) {
          return;
        }

        // focus wrapper
        wrapperEl[0].focus();

        // open custom menu
        scope.isOpen = true;
      };

      /**
       * Handle keydown event on wrapper element.
       * @param {Event} $event - Angular event instance
       */
      scope.onWrapperKeydown = function ($event) {
        // exit if preventDefault() was called or useDefault is true
        if ($event.defaultPrevented || scope.useDefault) return;

        var keyCode = $event.keyCode;

        if (scope.isOpen === false) {
          // spacebar, down, up
          if (keyCode === 32 || keyCode === 38 || keyCode === 40) {
            // prevent win scroll
            $event.preventDefault();

            // open menu
            scope.isOpen = true;
          }
        } else {
          // tab
          if (keyCode === 9) return scope.isOpen = false;

          // escape | up | down | enter
          if (keyCode === 27 || keyCode === 40 || keyCode === 38 || keyCode === 13) {
            $event.preventDefault();
          }

          if (keyCode === 27) {
            // close
            scope.isOpen = false;
          } else if (keyCode === 40) {
            // increment
            if (scope.menuIndex < scope.options.length - 1) {
              scope.menuIndex += 1;
            }
          } else if (keyCode === 38) {
            // decrement
            if (scope.menuIndex > 0) scope.menuIndex -= 1;
          } else if (keyCode === 13) {
            // choose and close
            scope.ngModel = scope.options[scope.menuIndex].value;
            scope.isOpen = false;
          }
        }
      };

      /**
       * Handle mousedown event on Inner <select> element
       * @param {Event} $event - Angular event instance
       */
      scope.onInnerMousedown = function ($event) {
        // check flag
        if ($event.button !== 0 || scope.useDefault === true) return;

        // prevent built-in menu from opening
        $event.preventDefault();
      };

      /**
       * Choose option the user selected.
       * @param {Object} option - The option selected.
       */
      scope.chooseOption = function ($event, option) {
        // prevent bubbling
        $event.stopImmediatePropagation();

        scope.ngModel = option.value;
        scope.isOpen = false;
      };

      // function to close menu on window resize and document click
      function closeMenuFn() {
        scope.isOpen = false;

        // disable scroll lock
        util.disableScrollLock(true);

        // remove event handlers
        jqLite.off(document, 'click', closeMenuFn);
        jqLite.off(window, 'resize', closeMenuFn);

        scope.$digest();
      }

      /**
       * Open/Close custom select menu
       */
      scope.$watch('isOpen', function (isOpen, oldVal) {
        // ignore first call
        if (isOpen === oldVal) return;

        // exit if use-default is true
        if (scope.useDefault === true) return;

        if (isOpen === true) {
          // enable scroll lock
          util.enableScrollLock();

          // init menuIndex
          var value = scope.ngModel,
              options = scope.options,
              m = options.length,
              i;

          for (i = 0; i < m; i++) {
            if (options[i].value === value) {
              scope.menuIndex = i;
              break;
            }
          }

          // set position of custom menu
          var props = formlib.getMenuPositionalCSS(element[0], scope.options.length, scope.menuIndex);

          menuEl.css(props);
          jqLite.scrollTop(menuEl[0], props.scrollTop);

          // attach event handlers
          $timeout(function () {
            jqLite.on(document, 'click', closeMenuFn);
            jqLite.on(window, 'resize', closeMenuFn);
          });
        } else {
          // focus select element
          selectEl[0].focus();

          // disable scroll lock
          util.disableScrollLock(true);

          // remove event handlers
          jqLite.off(document, 'click', closeMenuFn);
          jqLite.off(window, 'resize', closeMenuFn);
        }
      });

      scope.$watch('ngDisabled', function (newVal) {
        if (newVal === true) wrapperEl.prop('tabIndex', '-1');else if (!scope.useDefault) wrapperEl.prop('tabIndex', '0');
      });
    }
  };
}]);

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"../js/lib/forms":3,"../js/lib/jqLite":4,"../js/lib/util":5,"angular":"aeQg5j"}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = window.angular;

var _angular2 = babelHelpers.interopRequireDefault(_angular);

var _jqLite = require('../js/lib/jqLite');

var jqLite = babelHelpers.interopRequireWildcard(_jqLite);
/**
 * MUI Angular Tabs Component
 * @module angular/tabs
 */

var moduleName = 'mui.tabs';

_angular2.default.module(moduleName, []).directive('muiTabs', function () {
  return {
    restrict: 'EA',
    transclude: true,
    scope: {
      selectedId: '=?selected',
      onChange: '&?'
    },
    template: '' + '<ul ' + 'class="mui-tabs__bar" ' + 'ng-class=\'{"mui-tabs__bar--justified": justified}\'>' + '<li ' + 'ng-repeat="tab in tabs track by $index" ' + 'ng-class=\'{"mui--is-active": $index === selectedId}\'>' + '<a ng-click="onClick($index)">{{tab.label}}</a>' + '</li>' + '</ul>',
    controller: ['$scope', function ($scope) {
      var counter = 0;

      // init scope
      $scope.tabs = [];

      // add tab
      this.addTab = function (args) {
        // user counter for tab id
        var tabId = counter;
        counter += 1;

        // update tabs list
        $scope.tabs.push({ label: args.label });

        // handle active tabs
        if (args.isActive) $scope.selectedId = tabId;

        // return id
        return tabId;
      };
    }],
    link: function link(scope, element, attrs, ctrl, transcludeFn) {
      var isUndef = _angular2.default.isUndefined;

      // init scope
      if (isUndef(scope.selectedId)) scope.selectedId = 0;
      scope.justified = false;

      // justified
      if (!isUndef(attrs.justified)) scope.justified = true;

      // click handler
      scope.onClick = function (tabId) {
        // check current tab
        if (tabId === scope.selectedId) return;

        // update active tab
        scope.selectedId = tabId;

        // execute onChange callback
        if (scope.onChange) scope.$$postDigest(scope.onChange);
      };

      // use transcludeFn to pass ng-controller on parent element
      transcludeFn(scope, function (clone) {
        element.append(clone);
      });
    }
  };
}).directive('muiTab', ['$parse', function ($parse) {
  return {
    require: '^?muiTabs',
    restrict: 'AE',
    scope: {
      active: '&?',
      label: '@?'
    },
    transclude: true,
    template: '<div ' + 'class="mui-tabs__pane" ' + 'ng-class=\'{"mui--is-active": tabId === $parent.selectedId}\'></div>',
    link: function link(scope, element, attrs, ctrl, transcludeFn) {
      var onSelectFn = $parse(attrs.onSelect),
          onDeselectFn = $parse(attrs.onDeselect),
          origScope = scope.$parent.$parent;

      // init scope
      scope.tabId = null;

      // add to parent controller
      if (ctrl) {
        scope.tabId = ctrl.addTab({
          label: scope.label,
          isActive: Boolean(scope.active)
        });
      }

      // use transcludeFn to pass ng-controller on parent element
      transcludeFn(scope, function (clone) {
        element.find('div').append(clone);
      });

      scope.$parent.$watch('selectedId', function (newVal, oldVal) {
        // ignore initial load
        if (newVal === oldVal) return;

        // execute onSelect
        if (newVal === scope.tabId) onSelectFn(origScope);

        // execute onDeselect
        if (oldVal === scope.tabId) onDeselectFn(origScope);
      });
    }
  };
}]);

/** Define module API */
exports.default = moduleName;
module.exports = exports['default'];

},{"../js/lib/jqLite":4,"angular":"aeQg5j"}]},{},[1])